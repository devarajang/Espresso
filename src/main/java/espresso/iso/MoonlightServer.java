/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package espresso.iso;

import java.io.File;
import java.util.Map;

import javax.net.ssl.SSLException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.solab.iso8583.IsoMessage;
import com.solab.iso8583.MessageFactory;
import com.solab.iso8583.parse.ConfigParser;

import espresso.util.MessageHandlerUtil;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import io.netty.handler.ssl.OpenSsl;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.SslProvider;
import io.netty.util.concurrent.GlobalEventExecutor;
import moonlight.handlers.MessageHandler;

@Component
public class MoonlightServer {

	private static Logger logger = LoggerFactory.getLogger(MoonlightServer.class);

	private int port;

	public static ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
	
	private MessageFactory<IsoMessage> messageFactory;
	
	@Value("${ISO_PORT:3030}")
	private String isoPort;
	
	
	private MessageHandlerUtil util;

	public MoonlightServer() {
		
	}

	private SslContext getSslContext() throws SSLException {

		File serverCert = new File("C:/temp/cert_test/example_com.crt");
		File serverKey = new File("C:/temp/cert_test/example_com.key");
		String serverPass = "";
		SslProvider sslProvider = SslProvider.JDK;
		if (OpenSsl.isAvailable()) {
			if (SslProvider.isAlpnSupported(sslProvider)) {
				logger.info("Native SSL provider is available and supports ALPN; will use native provider.");
				sslProvider = SslProvider.OPENSSL_REFCNT;
			} else {
				logger.info("Native SSL provider is available, but does not support ALPN; will use JDK SSL provider.");
				sslProvider = SslProvider.JDK;
			}
		}

		logger.debug("SSl Provider - {0}", sslProvider);
		if (serverPass == null || serverPass.isEmpty()) {
			return SslContextBuilder.forServer(serverCert, serverKey).sslProvider(sslProvider).build();
		} else {
			return SslContextBuilder.forServer(serverCert, serverKey, serverPass).sslProvider(sslProvider).build();
		}
	}

	public void run() throws Exception {
		System.out.println("System Env " + System.getenv("ISO_PORTNUM"));
		System.out.println("Server Port = " + isoPort);
		port = Integer.parseInt(isoPort);
		EventLoopGroup bossGroup = new NioEventLoopGroup();
		EventLoopGroup workerGroup = new NioEventLoopGroup();
		messageFactory = ConfigParser.createFromClasspathConfig("j8583-config.xml");
		try {

			util = new MessageHandlerUtil();
			ServerBootstrap b = new ServerBootstrap();
			b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)
					.childHandler(new ChannelInitializer<SocketChannel>() {

						@Override
						protected void initChannel(SocketChannel ch) throws Exception {
							ch.pipeline().addLast(getSslContext().newHandler(ch.alloc()),
									new LoggingHandler(LogLevel.INFO), new MessageLengthFieldBasedFrameDecoder(),
									new ISOMessageDecoder(messageFactory), new ISOMessageEncoder(2, false),
									new ISOMessageHandler(util));

						}


					}).option(ChannelOption.SO_BACKLOG, 128).childOption(ChannelOption.SO_KEEPALIVE, true);
			

			ChannelFuture f = b.bind(port).sync();
			f.channel().closeFuture().sync();
		} finally {
			workerGroup.shutdownGracefully();
			bossGroup.shutdownGracefully();
		}
	}

	/**
	 * @return the port
	 */
	public int getPort() {
		return port;
	}

	/**
	 * @param port the port to set
	 */
	public void setPort(int port) {
		this.port = port;
	}

	public IsoMessage auth(Map<String, Object> authData) {
//		String  iso_message = "0200F23A441188E1806200000000000000121649414900222876570000000000000098500520154521000926154521052005205411062D000001501010000010091111111111111014100000926TERM  ID[88888888888888ACCEPTOR NAME          CITY NAME 013ACCEPTOR NAME840011100000000100170184088888    840022B2IN0100PLSINT100  0  005PI0100754000926462293     014100000926 000000000000311       012000        12345678";
		String iso_message = "0200F23A4401A8E19062000000000000001016494149002228765731000000000000000005291404410026261404410529052960119011010000005891111111111111374941490022287657=23051010000015500000000000001733PULTERM PUL12345SE     1005 convention plaza  st louis     MOUS013MERCHANT NAME84044F25BA5D86738130110000000002201729000         840022B2580001PULINT058  0  000";
		try{
			IsoMessage isomsg = messageFactory.parseMessage(iso_message.getBytes(), 0);
			System.out.println(" channel count - " + channels.size());
			for (Channel channel : MoonlightServer.channels) {
				ChannelFuture future = channel.writeAndFlush(isomsg);
		      //  future.addListener(ChannelFutureListener.CLOSE);
		        System.out.println(isomsg.debugString());
			}
			return isomsg;
		} catch (Exception e) {
			throw new RuntimeException();
		}
		
	}

	public IsoMessage keyex(Map<String, Object> keyexData) {
		MessageHandler messHandler = util.getByType(0x800);
		
		IsoMessage isomsg = messHandler.createMessage(keyexData);
		for (Channel channel : MoonlightServer.channels) {
			channel.writeAndFlush(isomsg);
	      //  future.addListener(ChannelFutureListener.CLOSE);
	        System.out.println(isomsg.debugString());
		}
		return isomsg;
//		String iso_message = "080082200000000000000400000100000008052217520600189510100022020036632D826A17939BA5CBA7A84BF771DCD51E7E";
//		try{
//			IsoMessage isomsg = messageFactory.parseMessage(iso_message.getBytes(), 0);
//			System.out.println(" channel count - " + channels.size());
//			for (Channel channel : MoonlightServer.channels) {
//				ChannelFuture future = channel.writeAndFlush(isomsg);
//		      //  future.addListener(ChannelFutureListener.CLOSE);
//		        System.out.println(isomsg.debugString());
//			}
//			return isomsg;
//		} catch (Exception e) {
//			throw new RuntimeException();
//		}
	}

	public IsoMessage netadm(Map<String, Object> netadmData) {
		MessageHandler messHandler = util.getByType(0x800);
		
		IsoMessage isomsg = messHandler.createMessage(netadmData);
		for (Channel channel : MoonlightServer.channels) {
			channel.writeAndFlush(isomsg);
	      //  future.addListener(ChannelFutureListener.CLOSE);
	        System.out.println(isomsg.debugString());
		}
		return isomsg;
	}

//	public 
//
//	public static void main(String[] args) throws Exception {
//
//		int port = args.length > 0 ? Integer.parseInt(args[0]) : 3030;
//		logger.info("starting server {}", port);
//
//		new MoonlightServer(port).run();
//	}
}
